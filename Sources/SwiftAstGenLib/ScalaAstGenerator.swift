import CodeGeneration
import Foundation

public class ScalaAstGenerator {

  private let defaultScalaOutFileUrl = URL(fileURLWithPath: "./SwiftNodeSyntax.scala")

  private func baseNode(node: Node) -> String {
    String(describing: node.base.syntaxType)
  }

  private func inheritsFrom(node: Node) -> [String] {
    let base = baseNode(node: node)
    let traits = node.layoutNode?.traits ?? []
    return [base] + traits
  }

  private func backtickedIfNeeded(name: String) -> String {
    if name == "type" { return "`\(name)`" } else { return name }
  }

  private let header: String = """
    // Automatically generated by 'SwiftAstGen --scalaAstOnly'.
    // Do not edit directly!

    import ujson.Value
    """

  public init() throws {
    if FileManager.default.fileExists(atPath: defaultScalaOutFileUrl.path) {
      try FileManager.default.removeItem(at: defaultScalaOutFileUrl)
    }
    FileManager.default.createFile(
      atPath: defaultScalaOutFileUrl.path,
      contents: nil,
      attributes: nil
    )
  }

  public func generate() throws {
    let allBaseNodeNames = Set(SYNTAX_NODES.map(baseNode)).map { "\($0)" }

    let baseNodes = allBaseNodeNames.map {
      """
      sealed trait \($0) extends SwiftNode
      """
    }

    let allTraits = TRAITS.map {
      if $0.documentation.isEmpty {
        "sealed trait \($0.traitName)"
      } else {
        """
        \n\t\(String(describing: $0.documentation).replacingOccurrences(of: "\n", with: "\n\t"))
        \tsealed trait \($0.traitName)
        """
      }
    }

    let filteredNodes = SYNTAX_NODES.filter { !allBaseNodeNames.contains("\($0.kind.syntaxType)") }
    let allNodes = filteredNodes.map { node in
      let syntaxType = node.kind.syntaxType
      let inherits = inheritsFrom(node: node)
      let inheritsString =
        if inherits.count == 1 {
          "extends \(inherits[0])"
        } else {
          "extends \(inherits[0]) with \(inherits[1...inherits.count-1].joined(separator: " with "))"
        }

      let allChildren = node.layoutNode?.children ?? []
      var childrenString = ""
      if allChildren.count != 0 {
        childrenString =
          allChildren
          .filter { !$0.isUnexpectedNodes }
          .map { child in
            let name = backtickedIfNeeded(name: "\(child.varOrCaseName)")
            let isOptional = child.isOptional
            let returnType = isOptional ? "Option[Value]" : "Value"
            let returnAccess = isOptional ? "" : ".head"
            return
              "\tdef \(name): \(returnType) = json(\"children\").arr.toList.find(_(\"name\").str == \"\(child.varOrCaseName)\")\(returnAccess)"
          }.joined(separator: "\n\t")
      } else {
        childrenString = "\tdef children: Seq[Value] = json(\"children\").arr.toList"
      }

      var documentation = String(describing: node.documentation)
      if documentation.isEmpty {
        documentation = "/// No documentation available."
      } else {
        documentation = documentation.replacingOccurrences(of: "\n", with: "\n\t")
      }

      let childrenDoc =
        node.layoutNode?.grammar ?? node.collectionNode?.grammar ?? "/// no children available"
      let childrenDocString = String(describing: childrenDoc).replacingOccurrences(
        of: "\n", with: "\n\t")

      var containedInDocString = String(describing: node.containedIn)
      containedInDocString = containedInDocString.replacingOccurrences(of: "\n", with: "\n\t")

      return """
        \n\t/// ### Documentation
        \t///
        \t\(documentation)
        \t///
        \t\(childrenDocString)
        \t///
        \t\(containedInDocString.isEmpty ? "/// ### Nowhere contained in" : containedInDocString)
        \tcase class \(syntaxType)(json: Value) \(inheritsString) {
          \(childrenString)
        \t}
        """
    }

    let allToken = Token.allCases.map {
      """
      case class \($0)(json: Value) extends SwiftToken
      """
    }

    let out = """
      \(header)

      object SwiftNodeSyntax {

        def createSwiftNode(json: Value): SwiftNode = {
          val nodeType = json("nodeType").str
          val tokenKind = json("tokenKind").str

          if (nodeType.nonEmpty) {
            \(filteredNodes.map { node in
              let syntaxType = node.kind.syntaxType
              return "if (nodeType == \"\(syntaxType)\") return \(syntaxType)(json)"
            }.joined(separator: "\n\t\t\t"))
            throw new UnsupportedOperationException(s"NodeType '$nodeType' is not a known Swift NodeType!")
          }

          if (tokenKind.nonEmpty) {
            \(Token.allCases.map { "if (tokenKind.startsWith(\"\($0)\")) return \($0)(json)" }.joined(separator: "\n\t\t\t"))
            throw new UnsupportedOperationException(s"TokenKind '$tokenKind' is not a known Swift TokenKind!")
          }

          throw new UnsupportedOperationException("Invalid SwiftSyntax json element. 'nodeType' and 'tokenKind' cannot be empty at the same time!")
        }

        sealed trait SwiftNode {
          override def toString: String = this.getClass.getSimpleName.stripSuffix("$")
        }

        sealed trait SwiftToken extends SwiftNode

        // MARK: tokens:
        \(allToken.joined(separator: "\n\t"))

        // MARK: base nodes:
        \(baseNodes.joined(separator: "\n\t"))

        // MARK: marker traits:
        \(allTraits.joined(separator: "\n\t"))

        // MARK: syntax nodes:
        \(allNodes.joined(separator: "\n\t"))

      }
      """

    try out.write(
      to: defaultScalaOutFileUrl,
      atomically: true,
      encoding: String.Encoding.utf8
    )

    print("Generated Scala Swift AST in file: `\(defaultScalaOutFileUrl.path)`")
  }

}
